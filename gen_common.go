package main

import (
	"fmt"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

func genGeneratedHeader(gen *protogen.Plugin, g *protogen.GeneratedFile, f *protogen.File) {
	g.P("// Code generated by protoc-gen-gopb. DO NOT EDIT.")

	g.P("// versions:")
	protocGenGoVersion := Version
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc-gen-gopb ", protocGenGoVersion)
	g.P("// \tprotoc          ", protocVersion)

	if f.Proto.GetOptions().GetDeprecated() {
		g.P("// ", f.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", f.Desc.Path())
	}
	g.P()
}

// Field numbers for google.protobuf.FileDescriptorProto.
const (
	FileDescriptorProto_Name_field_number             protoreflect.FieldNumber = 1
	FileDescriptorProto_Package_field_number          protoreflect.FieldNumber = 2
	FileDescriptorProto_Dependency_field_number       protoreflect.FieldNumber = 3
	FileDescriptorProto_PublicDependency_field_number protoreflect.FieldNumber = 10
	FileDescriptorProto_WeakDependency_field_number   protoreflect.FieldNumber = 11
	FileDescriptorProto_MessageType_field_number      protoreflect.FieldNumber = 4
	FileDescriptorProto_EnumType_field_number         protoreflect.FieldNumber = 5
	FileDescriptorProto_Service_field_number          protoreflect.FieldNumber = 6
	FileDescriptorProto_Extension_field_number        protoreflect.FieldNumber = 7
	FileDescriptorProto_Options_field_number          protoreflect.FieldNumber = 8
	FileDescriptorProto_SourceCodeInfo_field_number   protoreflect.FieldNumber = 9
	FileDescriptorProto_Syntax_field_number           protoreflect.FieldNumber = 12
	FileDescriptorProto_Edition_field_number          protoreflect.FieldNumber = 13
)

// genStandaloneComments prints all leading comments for a FileDescriptorProto
// location identified by the field number n.
func genStandaloneComments(g *protogen.GeneratedFile, f *protogen.File, n int32) {
	loc := f.Desc.SourceLocations().ByPath(protoreflect.SourcePath{n})
	for _, s := range loc.LeadingDetachedComments {
		g.P(protogen.Comments(s))
		g.P()
	}
	if s := loc.LeadingComments; s != "" {
		g.P(protogen.Comments(s))
		g.P()
	}
}

// structTags is a data structure for build idiomatic Go struct tags.
// Each [2]string is a key-value pair, where value is the unescaped string.
//
// Example: structTags{{"key", "value"}}.String() -> `key:"value"`
type structTags [][2]string

func (tags structTags) String() string {
	if len(tags) == 0 {
		return ""
	}
	var ss []string
	for _, tag := range tags {
		// NOTE: When quoting the value, we need to make sure the backtick
		// character does not appear. Convert all cases to the escaped hex form.
		key := tag[0]
		val := strings.Replace(strconv.Quote(tag[1]), "`", `\x60`, -1)
		ss = append(ss, fmt.Sprintf("%s:%s", key, val))
	}
	return "`" + strings.Join(ss, " ") + "`"
}

// appendDeprecationSuffix optionally appends a deprecation notice as a suffix.
func appendDeprecationSuffix(prefix protogen.Comments, parentFile protoreflect.FileDescriptor, deprecated bool) protogen.Comments {
	fileDeprecated := parentFile.Options().(*descriptorpb.FileOptions).GetDeprecated()
	if !deprecated && !fileDeprecated {
		return prefix
	}
	if prefix != "" {
		prefix += "\n"
	}
	if fileDeprecated {
		return prefix + " Deprecated: The entire proto file " + protogen.Comments(parentFile.Path()) + " is marked as deprecated.\n"
	}
	return prefix + " Deprecated: Marked as deprecated in " + protogen.Comments(parentFile.Path()) + ".\n"
}

// trailingComment is like protogen.Comments, but lacks a trailing newline.
type trailingComment protogen.Comments

func (c trailingComment) String() string {
	s := strings.TrimSuffix(protogen.Comments(c).String(), "\n")
	if strings.Contains(s, "\n") {
		// We don't support multi-lined trailing comments as it is unclear
		// how to best render them in the generated code.
		return ""
	}
	return s
}

func fieldJSONTagValue(field *protogen.Field) string {
	return string(field.Desc.Name()) + ",omitempty"
}

// func genImport(gen *protogen.Plugin, g *protogen.GeneratedFile, f *protogen.File, imp protoreflect.FileImport) {
// 	impFile, ok := gen.FilesByPath[imp.Path()]
// 	if !ok {
// 		return
// 	}
// 	if impFile.GoImportPath == f.GoImportPath {
// 		// Don't generate imports or aliases for types in the same Go package.
// 		return
// 	}
// 	// Generate imports for all non-weak dependencies, even if they are not
// 	// referenced, because other code and tools depend on having the
// 	// full transitive closure of protocol buffer types in the binary.
// 	if !imp.IsWeak {
// 		g.Import(impFile.GoImportPath)
// 	}
// 	if !imp.IsPublic {
// 		return
// 	}

// 	// Generate public imports by generating the imported file, parsing it,
// 	// and extracting every symbol that should receive a forwarding declaration.
// 	impGen := GenerateFile(gen, impFile)
// 	impGen.Skip()
// 	b, err := impGen.Content()
// 	if err != nil {
// 		gen.Error(err)
// 		return
// 	}
// 	fset := token.NewFileSet()
// 	astFile, err := parser.ParseFile(fset, "", b, parser.ParseComments)
// 	if err != nil {
// 		gen.Error(err)
// 		return
// 	}
// 	genForward := func(tok token.Token, name string, expr ast.Expr) {
// 		// Don't import unexported symbols.
// 		r, _ := utf8.DecodeRuneInString(name)
// 		if !unicode.IsUpper(r) {
// 			return
// 		}
// 		// Don't import the FileDescriptor.
// 		if name == impFile.GoDescriptorIdent.GoName {
// 			return
// 		}
// 		// Don't import decls referencing a symbol defined in another package.
// 		// i.e., don't import decls which are themselves public imports:
// 		//
// 		//	type T = somepackage.T
// 		if _, ok := expr.(*ast.SelectorExpr); ok {
// 			return
// 		}
// 		g.P(tok, " ", name, " = ", impFile.GoImportPath.Ident(name))
// 	}
// 	g.P("// Symbols defined in public import of ", imp.Path(), ".")
// 	g.P()
// 	for _, decl := range astFile.Decls {
// 		switch decl := decl.(type) {
// 		case *ast.GenDecl:
// 			for _, spec := range decl.Specs {
// 				switch spec := spec.(type) {
// 				case *ast.TypeSpec:
// 					genForward(decl.Tok, spec.Name.Name, spec.Type)
// 				case *ast.ValueSpec:
// 					for i, name := range spec.Names {
// 						var expr ast.Expr
// 						if i < len(spec.Values) {
// 							expr = spec.Values[i]
// 						}
// 						genForward(decl.Tok, name.Name, expr)
// 					}
// 				case *ast.ImportSpec:
// 				default:
// 					panic(fmt.Sprintf("can't generate forward for spec type %T", spec))
// 				}
// 			}
// 		}
// 	}
// 	g.P()
// }


